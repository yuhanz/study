<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>

		<script>

		const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
		camera.position.z = 1;

		const scene = new THREE.Scene();

		const geometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
		// const material = new THREE.MeshNormalMaterial();
		const material = new THREE.MeshStandardMaterial();

		const mesh = new THREE.Mesh( geometry, material );
		scene.add( mesh );

		const light2 = new THREE.AmbientLight( 0xf404040 ); // soft white light
		scene.add( light2 );

		const light = new THREE.PointLight( 0xff0000, 1, 0, 2 );
		light.position.set( -0.5, -0.5, 0.5 );
		scene.add( light );

		// const helper = new THREE.PointLightHelper(light)
		// scene.add(helper)

		const renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setAnimationLoop( animation );
		document.body.appendChild( renderer.domElement );

		function animation( time ) {

			mesh.rotation.x = time / 2000;
			mesh.rotation.y = time / 1000;

			renderer.render( scene, camera );
			rayTrace()

		}


		// animation
		//animation(9034102)

		// helper.update()


		// const loader = new THREE.OBJLoader();
		// loader.load(
		// 	// resource URL
		// 	'model/bunny.obj',
		// 	// called when resource is loaded
		// 	function ( object ) {
		//
		// 		scene.add( object );
		//
		// 	},
		// 	// called when loading is in progresses
		// 	function ( xhr ) {
		//
		// 		console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
		//
		// 	},
		// 	// called when loading has errors
		// 	function ( error ) {
		//
		// 		console.log( 'An error happened' );
		//
		// 	}
		// );
		var previousCanvas = null

		function rayTrace() {
			// const canvas = document.getElementsByTagName('canvas')[0]
			// var ctx = canvas.getContext('2d');
			// var canvasWidth = canvas.width;
			// var canvasHeight = canvas.height
			// var id = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
			// var pixels = id.data;
			var canvas = document.createElement("CANVAS");
			canvasWidth = canvas.width = window.innerWidth
			canvasHeight = canvas.height = window.innerHeight
			var ctx = canvas.getContext("2d");
			ctx.fillStyle = "black";
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			var id = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
			var pixels = id.data;

			for(var j=0;j<window.innerHeight;j++) {
				for(var i=0;i<window.innerWidth;i++) {
					const geometry = mesh.geometry

					// Need to be between -1 and 1
					const pointer = new THREE.Vector2();
					pointer.x = -1 + (2*i/window.innerWidth)
					pointer.y = 1 + (2*j/window.innerHeight*(-1))

					const raycaster = new THREE.Raycaster()

					raycaster.setFromCamera( pointer, camera );
					const intersects = []
					mesh.raycast(raycaster, intersects)

					if(intersects.length > 0) {
						// TODO: order the intersections to pick the planes facing the camera
						const intersect = intersects[0]

						const point = intersect.point
						const faceNormal = intersect.face.normal.clone().applyMatrix4(mesh.matrix)
						// TODO: rotate faceNormal

						// Get reflection direction
						const rayDirection = camera.position.clone().sub(point.clone()).normalize()
						//const reflectedDirection = rayDirection.clone().reflect(faceNormal)
						const reflectedDirection = rayDirection.applyAxisAngle(faceNormal, Math.PI)
						const lightDirection = light.position.clone().sub(point.clone()).normalize()
						// TODO: make light move with the camera


						const intensityEffect = reflectedDirection.dot(lightDirection)
						//console.log(i,j, intensityEffect)

						// render the intensity to a canvas
						var off = (j * id.width + i) * 4;
						//pixels[off] = Math.floor(255 * Math.abs(intensityEffect));
						pixels[off] = 50 + Math.floor(205 * Math.max(0, intensityEffect));
						pixels[off + 1] = 50;
						pixels[off + 2] = 50;
						pixels[off + 3] = 255;
					}

				}
			}

			ctx.putImageData(id, 0, 0);
			if(previousCanvas) {
				document.body.removeChild(previousCanvas)
			}
			document.body.appendChild(canvas)
			previousCanvas = canvas
		}

		setTimeout(() => {
		  rayTrace()
		}, "1000")
		// rayTrace()

		</script>
		<canvas id="myCanvas" width="200" height="100"></canvas>
	</body>
</html>
